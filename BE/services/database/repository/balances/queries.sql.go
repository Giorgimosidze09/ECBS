// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package repository_balances

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBalanceToCard = `-- name: AddBalanceToCard :one
UPDATE balances
SET balance = balance + $2, updated_at = NOW()
WHERE card_id = $1
RETURNING user_id, card_id, balance, updated_at
`

type AddBalanceToCardParams struct {
	CardID  int32          `json:"card_id"`
	Balance pgtype.Numeric `json:"balance"`
}

type AddBalanceToCardRow struct {
	UserID    pgtype.Int4        `json:"user_id"`
	CardID    int32              `json:"card_id"`
	Balance   pgtype.Numeric     `json:"balance"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) AddBalanceToCard(ctx context.Context, arg AddBalanceToCardParams) (AddBalanceToCardRow, error) {
	row := q.db.QueryRow(ctx, addBalanceToCard, arg.CardID, arg.Balance)
	var i AddBalanceToCardRow
	err := row.Scan(
		&i.UserID,
		&i.CardID,
		&i.Balance,
		&i.UpdatedAt,
	)
	return i, err
}

const balaneList = `-- name: BalaneList :many
SELECT
  b.id, b.user_id, b.card_id, b.ride_cost, b.balance, b.updated_at,
  COUNT(*) OVER() AS total
FROM balances b
ORDER BY b.id
LIMIT $1 OFFSET $2
`

type BalaneListParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type BalaneListRow struct {
	ID        int32              `json:"id"`
	UserID    pgtype.Int4        `json:"user_id"`
	CardID    int32              `json:"card_id"`
	RideCost  pgtype.Numeric     `json:"ride_cost"`
	Balance   pgtype.Numeric     `json:"balance"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Total     int64              `json:"total"`
}

func (q *Queries) BalaneList(ctx context.Context, arg BalaneListParams) ([]BalaneListRow, error) {
	rows, err := q.db.Query(ctx, balaneList, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BalaneListRow
	for rows.Next() {
		var i BalaneListRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CardID,
			&i.RideCost,
			&i.Balance,
			&i.UpdatedAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const costOfRide = `-- name: CostOfRide :exec
UPDATE balances
SET
    ride_cost = $1,
    updated_at = NOW()
`

func (q *Queries) CostOfRide(ctx context.Context, rideCost pgtype.Numeric) error {
	_, err := q.db.Exec(ctx, costOfRide, rideCost)
	return err
}

const deductBalance = `-- name: DeductBalance :exec
UPDATE balances SET balance = balance - $1, updated_at = NOW() WHERE user_id = $2 AND balance >= $1
`

type DeductBalanceParams struct {
	Balance pgtype.Numeric `json:"balance"`
	UserID  pgtype.Int4    `json:"user_id"`
}

func (q *Queries) DeductBalance(ctx context.Context, arg DeductBalanceParams) error {
	_, err := q.db.Exec(ctx, deductBalance, arg.Balance, arg.UserID)
	return err
}

const getBalanceByUserID = `-- name: GetBalanceByUserID :one
SELECT user_id, balance, ride_cost, updated_at
FROM balances
WHERE user_id = $1
`

type GetBalanceByUserIDRow struct {
	UserID    pgtype.Int4        `json:"user_id"`
	Balance   pgtype.Numeric     `json:"balance"`
	RideCost  pgtype.Numeric     `json:"ride_cost"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetBalanceByUserID(ctx context.Context, userID pgtype.Int4) (GetBalanceByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getBalanceByUserID, userID)
	var i GetBalanceByUserIDRow
	err := row.Scan(
		&i.UserID,
		&i.Balance,
		&i.RideCost,
		&i.UpdatedAt,
	)
	return i, err
}

const getSumBalanceByDeviceID = `-- name: GetSumBalanceByDeviceID :one
SELECT COALESCE(SUM(b.balance), 0) AS total_balance
FROM balances b
JOIN cards c ON b.card_id = c.id
JOIN devices d ON c.device_id = d.id
WHERE d.device_id = $1
`

func (q *Queries) GetSumBalanceByDeviceID(ctx context.Context, deviceID string) (interface{}, error) {
	row := q.db.QueryRow(ctx, getSumBalanceByDeviceID, deviceID)
	var total_balance interface{}
	err := row.Scan(&total_balance)
	return total_balance, err
}

const topUpBalance = `-- name: TopUpBalance :one
INSERT INTO balances (user_id, card_id, balance, ride_cost, updated_at)
VALUES ($1, $2, $3, $4,NOW())
ON CONFLICT (user_id, card_id)
DO UPDATE SET balance = EXCLUDED.balance, updated_at = NOW()
RETURNING user_id, card_id, balance, updated_at
`

type TopUpBalanceParams struct {
	UserID   pgtype.Int4    `json:"user_id"`
	CardID   int32          `json:"card_id"`
	Balance  pgtype.Numeric `json:"balance"`
	RideCost pgtype.Numeric `json:"ride_cost"`
}

type TopUpBalanceRow struct {
	UserID    pgtype.Int4        `json:"user_id"`
	CardID    int32              `json:"card_id"`
	Balance   pgtype.Numeric     `json:"balance"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) TopUpBalance(ctx context.Context, arg TopUpBalanceParams) (TopUpBalanceRow, error) {
	row := q.db.QueryRow(ctx, topUpBalance,
		arg.UserID,
		arg.CardID,
		arg.Balance,
		arg.RideCost,
	)
	var i TopUpBalanceRow
	err := row.Scan(
		&i.UserID,
		&i.CardID,
		&i.Balance,
		&i.UpdatedAt,
	)
	return i, err
}

const totalBalance = `-- name: TotalBalance :one
SELECT COALESCE(SUM(balance), 0) FROM balances
`

func (q *Queries) TotalBalance(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, totalBalance)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}
