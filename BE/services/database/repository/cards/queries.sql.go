// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package repository_cards

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cardsList = `-- name: CardsList :many
SELECT
  c.id,
  c.card_id,
  c.user_id,
  c.device_id,
  c.type,
  c.active,
  c.assigned_at,
  COUNT(*) OVER() AS total
FROM cards c
JOIN users u ON u.id = c.user_id
WHERE u.deleted = false
ORDER BY c.id
LIMIT $1 OFFSET $2
`

type CardsListParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type CardsListRow struct {
	ID         int32              `json:"id"`
	CardID     string             `json:"card_id"`
	UserID     int32              `json:"user_id"`
	DeviceID   int32              `json:"device_id"`
	Type       string             `json:"type"`
	Active     pgtype.Bool        `json:"active"`
	AssignedAt pgtype.Timestamptz `json:"assigned_at"`
	Total      int64              `json:"total"`
}

func (q *Queries) CardsList(ctx context.Context, arg CardsListParams) ([]CardsListRow, error) {
	rows, err := q.db.Query(ctx, cardsList, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CardsListRow
	for rows.Next() {
		var i CardsListRow
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.UserID,
			&i.DeviceID,
			&i.Type,
			&i.Active,
			&i.AssignedAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countCards = `-- name: CountCards :one
SELECT COUNT(*) FROM cards
`

func (q *Queries) CountCards(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCards)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCard = `-- name: CreateCard :one
INSERT INTO Cards (card_id, user_id, device_id, active, type, assigned_at)
VALUES ($1, $2, $3, $4, $5, NOW())
ON CONFLICT (id) DO NOTHING
RETURNING id, card_id, user_id, device_id, active, type, assigned_at
`

type CreateCardParams struct {
	CardID   string      `json:"card_id"`
	UserID   int32       `json:"user_id"`
	DeviceID int32       `json:"device_id"`
	Active   pgtype.Bool `json:"active"`
	Type     string      `json:"type"`
}

type CreateCardRow struct {
	ID         int32              `json:"id"`
	CardID     string             `json:"card_id"`
	UserID     int32              `json:"user_id"`
	DeviceID   int32              `json:"device_id"`
	Active     pgtype.Bool        `json:"active"`
	Type       string             `json:"type"`
	AssignedAt pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (CreateCardRow, error) {
	row := q.db.QueryRow(ctx, createCard,
		arg.CardID,
		arg.UserID,
		arg.DeviceID,
		arg.Active,
		arg.Type,
	)
	var i CreateCardRow
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.UserID,
		&i.DeviceID,
		&i.Active,
		&i.Type,
		&i.AssignedAt,
	)
	return i, err
}

const createCardActivation = `-- name: CreateCardActivation :one
INSERT INTO card_activations (card_id, activation_start, activation_end, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, card_id, activation_start, activation_end, created_at, updated_at
`

type CreateCardActivationParams struct {
	CardID          int32       `json:"card_id"`
	ActivationStart pgtype.Date `json:"activation_start"`
	ActivationEnd   pgtype.Date `json:"activation_end"`
}

func (q *Queries) CreateCardActivation(ctx context.Context, arg CreateCardActivationParams) (CardActivation, error) {
	row := q.db.QueryRow(ctx, createCardActivation, arg.CardID, arg.ActivationStart, arg.ActivationEnd)
	var i CardActivation
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.ActivationStart,
		&i.ActivationEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCardByCardID = `-- name: GetCardByCardID :one
SELECT c.id, c.card_id, c.user_id, c.active, c.type, u.name as user_name
FROM cards c
JOIN users u ON u.id = c.user_id
WHERE c.id = $1
`

type GetCardByCardIDRow struct {
	ID       int32       `json:"id"`
	CardID   string      `json:"card_id"`
	UserID   int32       `json:"user_id"`
	Active   pgtype.Bool `json:"active"`
	Type     string      `json:"type"`
	UserName string      `json:"user_name"`
}

func (q *Queries) GetCardByCardID(ctx context.Context, id int32) (GetCardByCardIDRow, error) {
	row := q.db.QueryRow(ctx, getCardByCardID, id)
	var i GetCardByCardIDRow
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.UserID,
		&i.Active,
		&i.Type,
		&i.UserName,
	)
	return i, err
}

const getCardByID = `-- name: GetCardByID :one
SELECT id, card_id, user_id, device_id, active, type, assigned_at FROM cards WHERE id = $1
`

type GetCardByIDRow struct {
	ID         int32              `json:"id"`
	CardID     string             `json:"card_id"`
	UserID     int32              `json:"user_id"`
	DeviceID   int32              `json:"device_id"`
	Active     pgtype.Bool        `json:"active"`
	Type       string             `json:"type"`
	AssignedAt pgtype.Timestamptz `json:"assigned_at"`
}

func (q *Queries) GetCardByID(ctx context.Context, id int32) (GetCardByIDRow, error) {
	row := q.db.QueryRow(ctx, getCardByID, id)
	var i GetCardByIDRow
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.UserID,
		&i.DeviceID,
		&i.Active,
		&i.Type,
		&i.AssignedAt,
	)
	return i, err
}

const getCardByItsCardID = `-- name: GetCardByItsCardID :one
SELECT c.id, c.card_id, c.user_id, c.active, c.type, u.name as user_name
FROM cards c
JOIN users u ON u.id = c.user_id
WHERE c.card_id = $1
`

type GetCardByItsCardIDRow struct {
	ID       int32       `json:"id"`
	CardID   string      `json:"card_id"`
	UserID   int32       `json:"user_id"`
	Active   pgtype.Bool `json:"active"`
	Type     string      `json:"type"`
	UserName string      `json:"user_name"`
}

func (q *Queries) GetCardByItsCardID(ctx context.Context, cardID string) (GetCardByItsCardIDRow, error) {
	row := q.db.QueryRow(ctx, getCardByItsCardID, cardID)
	var i GetCardByItsCardIDRow
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.UserID,
		&i.Active,
		&i.Type,
		&i.UserName,
	)
	return i, err
}

const softDeleteCard = `-- name: SoftDeleteCard :exec
UPDATE cards SET deleted = TRUE WHERE id = $1
`

func (q *Queries) SoftDeleteCard(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeleteCard, id)
	return err
}

const updateCard = `-- name: UpdateCard :exec
UPDATE cards SET card_id = $2, user_id = $3, device_id = $4, type = $5, active = $6 WHERE id = $1
`

type UpdateCardParams struct {
	ID       int32       `json:"id"`
	CardID   string      `json:"card_id"`
	UserID   int32       `json:"user_id"`
	DeviceID int32       `json:"device_id"`
	Type     string      `json:"type"`
	Active   pgtype.Bool `json:"active"`
}

func (q *Queries) UpdateCard(ctx context.Context, arg UpdateCardParams) error {
	_, err := q.db.Exec(ctx, updateCard,
		arg.ID,
		arg.CardID,
		arg.UserID,
		arg.DeviceID,
		arg.Type,
		arg.Active,
	)
	return err
}
